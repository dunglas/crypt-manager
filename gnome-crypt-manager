#!/usr/bin/python
# vim: set fileencoding=utf-8 :
# Copyright (C) 2007 Kévin Dunglas <dunglas@gmail.com>
#
# Authors:
#  Kévin Dunglas
#
# This program is a part of a the Google Summer Of Code 2007
# For futher information see :
# http://code.google.com/soc/ubuntu/appinfo.html?csaid=EF4FCF874D88234
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA 02111-1307 USA

import os
import sys
import cPickle
import gtk
import gnome.ui
import gtk.glade
import threading
import time
import cryptmanager

APPNAME="gnome-crypt-manager"
APPVERSION="0.1"
CACHE = os.environ['HOME'] + "/.config/cryptmanager/cache"

class GladeHandlers:
    """Connectors to GTK/Glade events"""
    def gtk_main_quit(event):
        WidgetsWrapper.quit(widgets)

    def on_manager_add_clicked(event):
        Crypt()

    def on_crypt_apply_clicked(event):
        path = widgets["crypt_path"].get_text()
        password = widgets["crypt_password"].get_text()
        size = widgets["crypt_size"].get_value_as_int()
        if Valid().crypt(path, size):
            Encrypt(path, size, password)
            widgets["crypt"].hide()

    def on_crypt_cancel_clicked(event):
        WidgetsWrapper.hide_or_quit(widgets, "crypt")

    def on_password_cancel_clicked(event):
        WidgetsWrapper.hide_or_quit(widgets, "password")
    
    def on_password_apply_clicked(event):
        self.encrypt    = widgets["password_password"].get_text()
        widgets["password"].hide()
    
    def on_crypt_open_clicked(event):
        widgets["filechooserdialog"].show()
        
    def on_filechooserdialog_cancel_clicked(event):
        widgets["filechooserdialog"].hide()
    
    def on_filechooserdialog_open_clicked(event):
        path = widgets["filechooserdialog"].get_filename()
        widgets["crypt_path"].set_text(path)
        widgets["filechooserdialog"].hide()

    def on_error_ok_clicked(event):
        widgets["error"].hide()
    
    def on_manager_list_cursor_changed(event):
        (m, i) = widgets["manager_list"].get_selection().get_selected()
        print m.get_value(i, 2)
        if m.get_value(i, 2) == "True":
            widgets["manager_open_close"].set_label("gtk-close")
        else:
            widgets["manager_open_close"].set_label("gtk-open")
        widgets["manager_open_close"].set_sensitive(True)
    
    def on_manager_open_close_clicked(event):
        (m, i) = widgets["manager_list"].get_selection().get_selected()
        v = m.get_value(i, 3)
        Open(v)


class WidgetsWrapper:
    """Wrapper for GTK/Galde widgets"""
    def __init__(self):
        """Display a window"""
        gnome.init(APPNAME, APPVERSION)
        self.widgets = gtk.glade.XML("gnome-crypt-manager.glade")
        self.widgets.signal_autoconnect(GladeHandlers.__dict__)

    def __getitem__(self, key):
        """Allow to use widgets['widget_name'].action()"""
        return self.widgets.get_widget(key)

    def hide_or_quit(self, name):
        """Hide or quit the window"""
        if widgets["manager"].get_property("visible"):
            widgets[name].hide()
        else:
            self.quit()

    def quit(self):
        """Quit the program"""
        gtk.main_quit()


class Manager:
    """Main window"""
    def __init__(self, folders):
        """Launch the Cypted Folder manager"""
        widgets["manager"].show()
        column0 = gtk.TreeViewColumn("Folder name", gtk.CellRendererText(), text=0)
        column0.set_resizable(True)
        column0.set_sort_column_id(0)
        
        column1 = gtk.TreeViewColumn("Size", gtk.CellRendererText(), text=1)
        column1.set_resizable(True)
        column1.set_sort_column_id(1)
        
        column2 = gtk.TreeViewColumn("Opened", gtk.CellRendererText(), text=2)
        column2.set_resizable(True)
        column2.set_sort_column_id(2)
        
        column3 = gtk.TreeViewColumn("Full path", gtk.CellRendererText(), text=3)
        column3.set_resizable(True)
        column3.set_sort_column_id(3)
        
        widgets["manager_list"].append_column(column0)
        widgets["manager_list"].append_column(column1)
        widgets["manager_list"].append_column(column2)
        widgets["manager_list"].append_column(column3)
        
        self.folderList = gtk.ListStore(str, str, str, str)
        widgets["manager_list"].set_model(self.folderList)
        self.update()

    def update(self):
        """Update the tree view with the content of folders"""
        self.folderList.clear()
        for f in folders.li:
            path = f.path.split("/")
            path = path[len(path) - 1]
            self.folderList.append([path, f.size, f.opened, f.path])
   
                
    def add(folder):
        """Add a folder to the list"""
        pass


class Crypt:
    """Encrypted folder chooser"""
    def __init__(self, path=None, size=None):
        if path is not None and os.path.exists(path):
            widgets["crypt_path"].set_text(path)
        if size is not None and size.isdigit():
            widgets["crypt_size"].set_value(size)
        widgets["crypt"].show()
    
class Valid:
    """Validation methods"""
    def error_box(self, msg):
        #"""Display an error box"
        widgets["error_error"].set_text(msg)
        widgets["error"].show()

    def crypt(self, path, size):
        """Validation for the crypt window"""
        
        if not os.path.exists(path):
            self.error_box("You must select a valid folder")
            return False
        if size == 0:
            self.error_box("The size of your crypted folder cannot be null")
            return False
        return True
    
class Encrypt:
    """Ask for the password and encrypt a folder while displaying a progress bar"""
    
    def __init__(self, path, size, password):
        self.folder = cryptmanager.Folder(path, size)
        self.folder.processing = True
        #t = threading.Thread(target=self.progress_bar)
        #t.start()
        try:
            cryptmanager.Manage(self.folder).crypt(password) 
        except cryptmanager.IMGexists:
            Valid().error_box(self.folder.path + " is already a crypted folder.")
            #exit(folder.path + " is already a crypted folder.")
        else:
            folders.add(self.folder)
            manager.update()

    def progress_bar(self):
        """Display a progress Bar while processing operations on a folder"""
        widgets["progressbar"].show()
        while self.folder.processing == True:
            widgets["progressbar_progressbar"].pulse()
            time.sleep(1)
        widgets["progressbar"].hide()


class Mount:
    def __init__(self, path=None):
        """Mount an encrypted folder"""
        widgets["password"].show()
        folder = cryptmanager.Folder(path, size)
        try:
            cryptmanager.Manage(folder).crypt(password)
        except cryptmanager.IMGexists:
            exit(folder.path + " is already a crypted folder.")
        else:
            folders.add(folder)
            exit()


class Unmount:
    def __init__(self, folder):
        """Unmount an encrypted folder"""
        widgets["password"].show()
        self.d = d


def save_data():
    if folders == None:
        return
    if not os.path.exists(CACHE):
        os.makedirs(CACHE)
    f = open(os.path.join(CACHE, "folders"), "w")
    cPickle.dump(folders, f, protocol = cPickle.HIGHEST_PROTOCOL)
    f.close()


def load_data():
    if not os.path.exists(os.path.join(CACHE, "folders")):
        return cryptmanager.Folders()
    f = open(os.path.join(CACHE, "folders"), "r")
    folders = cPickle.load(f)
    f.close()
    return folders


def exit(para=0):
    save_data()
    sys.exit(para)


if __name__ == '__main__':
    folders = load_data()
    widgets = WidgetsWrapper()
    
    # Command Line Interface
    if len(sys.argv) == 1:
        manager = Manager(folders)
        
    elif len(sys.argv) == 2 and sys.argv[1] == "--help":
        msg = APPNAME + """, an encrypted folder manager
Options:
--crypt [DIRECTORY] [SIZE]  encrypt directory
--open [DIRECTORY]          open an encrypted folder
--help                      display this help message
--close [DIRECTORY]         close an encrypted folder
--uncrypt [DIRECTORY]       uncrypt encrypted folder
--version                   display version information"""
        exit(msg)
        
    elif len(sys.argv) == 2 and sys.argv[1] == "--version":
        msg = APPNAME + " " + APPVERSION
        exit(msg)

    elif len(sys.argv) >= 2 and len(sys.argv) <= 4 and sys.argv[1] == "--crypt":
        c = Crypt()

    elif len(sys.argv) == 3 and sys.argv[1] == "--close":
        try:
            folder = folders.get(sys.argv[2])
        except cryptmanager.Uncrypted:
            exit("This is not a crypted direcotry")
        try:
            folder = cryptmanager.Manage(folder).unmount()
        except cryptmanager.NotOpened:
            exit("This folder is not opened")
        folders.update(folder)
        exit()

    elif len(sys.argv) == 3 and sys.argv[1] == "--open":
        try:
            folder = folders.get(sys.argv[2])
        except cryptmanager.Uncrypted:
            exit("This is not a crypted direcyory")
        password = raw_input("Password: ")
        try:
            folder = cryptmanager.Manage(folder).mount(password)
        except cryptmanager.AlreadyOpened:
            exit(folder.path + " is already opened")
        except cryptmanager.BadPassword:
            exit("Your password is wrong")
        else:
            folders.update(folder)
            exit()

    elif len(sys.argv) == 3 and sys.argv[1] == "--uncrypt":
        folder = folders.get(sys.argv[2])
        password = raw_input("Password: ")
        cryptmanager.Manage(folder).uncrypt(password)
        folders.rem(folder)
        exit()

    else:
        msg = """Invalid option
Try « """ + APPNAME + """ --help » to get more information"""
        exit(msg)

    gtk.main()
    exit()
