#!/usr/bin/python
# vim: set fileencoding=utf-8 :
# Copyright (C) 2007 Kévin Dunglas <dunglas@gmail.com>
#
# Authors:
#  Kévin Dunglas
#
# This program is a part of a the Google Summer Of Code 2007
# For futher information see :
# http://code.google.com/soc/ubuntu/appinfo.html?csaid=EF4FCF874D88234
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA 02111-1307 USA

import os
import sys
import cPickle
import pygtk
pygtk.require('2.0')
import gtk
import gtk.glade
from time import sleep
import threading
import cryptmanager

APPNAME="gcrypt-manager"
APPVERSION="0.1"
CACHE = os.environ['HOME'] + "/.cryptmanager/cache"

class GladeHandlers:
    """Connectors to GTK/Glade events"""
    def gtk_main_quit(event):
        WidgetsWrapper.quit(widgets)

    def on_manager_add_clicked(event):
        widgets["manager"].set_sensitive(False)
        Crypt()

    def on_crypt_apply_clicked(event):
        path = widgets["crypt_path"].get_text()
        password = widgets["crypt_password"].get_text()
        size = widgets["crypt_size"].get_value_as_int()
        if Util().crypt(path, size):
            Encrypt(path, size, password)
            #WidgetsWrapper.hide_or_quit(widgets, "crypt")

    def on_crypt_cancel_clicked(event):
        WidgetsWrapper.hide_or_quit(widgets, "crypt")

    def on_open_cancel_clicked(event):
        WidgetsWrapper.hide_or_quit(widgets, "open")
    
    def on_open_apply_clicked(event):
        Mount(widgets["open_path"].get_text(), widgets["open_password"].get_text())
    
    def on_decrypt_cancel_clicked(event):
        WidgetsWrapper.hide_or_quit(widgets, "decrypt")
    
    def on_decrypt_apply_clicked(event):
        Sdecrypt(widgets["decrypt_path"].get_text(), widgets["decrypt_password"].get_text())
        WidgetsWrapper.hide_or_quit(widgets, "decrypt")
    
    def on_crypt_open_clicked(event):
        widgets["filechooserdialog"].show()
        
    def on_filechooserdialog_cancel_clicked(event):
        widgets["filechooserdialog"].hide()
    
    def on_filechooserdialog_open_clicked(event):
        path = widgets["filechooserdialog"].get_filename()
        widgets["crypt_path"].set_text(path)
        widgets["filechooserdialog"].hide()

    def on_error_close_clicked(event):
        widgets["error"].hide()
    
    def on_manager_list_cursor_changed(event):
        (m, i) = widgets["manager_list"].get_selection().get_selected()
        if m.get_value(i, 2) == "Yes":
            widgets["manager_open_close"].set_label("gtk-close")
        else:
            widgets["manager_open_close"].set_label("gtk-open")
        widgets["manager_open_close"].set_sensitive(True)
    
    def on_manager_open_close_clicked(event):
        widgets["manager"].set_sensitive(False)
        (m, i) = widgets["manager_list"].get_selection().get_selected()
        path = m.get_value(i, 3)
        if m.get_value(i, 2) == "Yes":
            Unmount(path)
        else:
            Open(path)
    
    def on_manager_decrypt_clicked(event):
        widgets["manager"].set_sensitive(False)
        (m, i) = widgets["manager_list"].get_selection().get_selected()
        path = m.get_value(i, 3)
        Decrypt(path)


class WidgetsWrapper:
    """Wrapper for GTK/Galde widgets"""
    def __init__(self):
        """Display a window"""
        #gnome.init(APPNAME, APPVERSION)
        self.widgets = gtk.glade.XML("gcrypt-manager.glade")
        self.widgets.signal_autoconnect(GladeHandlers.__dict__)

    def __getitem__(self, key):
        """Allow to use widgets['widget_name'].action()"""
        return self.widgets.get_widget(key)

    def hide_or_quit(self, name):
        """Hide or quit the window"""
        if widgets["manager"].get_property("visible"):
            widgets[name].hide()
            widgets["manager"].set_sensitive(True)
        else:
            self.quit()

    def quit(self):
        """Quit the program"""
        gtk.main_quit()


class Util:
    """Utilities"""
    def error_box(self, msg):
        """Display an error box"""
        widgets["error_label"].set_markup("<span weight=\"bold\">" + msg + "</span>")
        widgets["error"].show()
    
    def warning_box(self, msg):
        """Display a warning box"""
        widgets["warning_label"].set_markup("<span weight=\"bold\">" + msg + "</span>")
        widgets["warning"].show()

    def crypt(self, path, size):
        """Validation for the crypt window"""
        
        if not os.path.exists(path):
            self.error_box("You must select a valid folder")
            return False
        if size == 0:
            self.error_box("The size of your crypted folder cannot be null")
            return False
        ms = cryptmanager.Util().min_size(path, size)
        if ms != 0:
            widgets["crypt_size"].set_value(ms)
            self.error_box("Size too small, cannot contain current data")
            return False
        return True

    def progress_bar_start(self, msg=None):
        """Display a progress bar"""
        widgets["progressbar"].show()
        #gtk.gdk.threads_init()
        #Creating and starting the thread
        #self.pulser = Pulser()
        #self.pulser.start()
    
    def progress_bar_stop(self):
        #self.pulser.stop()
        widgets["progressbar"].hide()


class Pulser(threading.Thread):
    """Pulse the progressbar"""
    
    stopthread = threading.Event()
    
    def run(self):
        while not self.stopthread.isSet() :
            gtk.gdk.threads_enter()
            widgets["progressbar_progressbar"].pulse()
            gtk.gdk.threads_leave()
            sleep(0.1)

    def stop(self):
        """Stop method, sets the event to terminate the thread's main loop"""
        self.stopthread.set()


class Progressbar:
    """Display a pulsing progressbar"""
    def __init__(self, msg=None):
        self.msg = msg

    def start(self):
        """Start the progress bar"""
        if self.msg is not None:
            widgets["progressbar"].set_title(self.msg)
            widgets["progressbar_progressbar"].set_text(self.msg)
        widgets["progressbar"].show()
        self.pulser = Pulser()
        self.pulser.start()

    def stop(self):
        """Stop the progressbar"""
        widgets["progressbar"].hide()
        self.pulser.stop()
    

class Manager:
    """Main window"""
    def __init__(self, folders):
        """Launch the Cypted Folder manager"""
        widgets["manager"].show()
        column0 = gtk.TreeViewColumn("Folder name", gtk.CellRendererText(), text=0)
        column0.set_resizable(True)
        column0.set_sort_column_id(0)
        
        column1 = gtk.TreeViewColumn("Size (in MB)", gtk.CellRendererText(), text=1)
        column1.set_resizable(True)
        column1.set_sort_column_id(1)
        
        column2 = gtk.TreeViewColumn("Open", gtk.CellRendererText(), text=2)
        column2.set_resizable(True)
        column2.set_sort_column_id(2)
        
        column3 = gtk.TreeViewColumn("Full path", gtk.CellRendererText(), text=3)
        column3.set_resizable(True)
        column3.set_sort_column_id(3)
        
        widgets["manager_list"].append_column(column0)
        widgets["manager_list"].append_column(column1)
        widgets["manager_list"].append_column(column2)
        widgets["manager_list"].append_column(column3)
        
        self.folderList = gtk.ListStore(str, str, str, str)
        widgets["manager_list"].set_model(self.folderList)
        self.update()

    def update(self):
        """Update the tree view with the folders list"""
        self.folderList.clear()
        for f in folders.li:
            path = f.path.split("/")
            path = path[len(path) - 1]
            if f.opened == True:
                o = "Yes"
            else:
                o = "No"
            self.folderList.append([path, f.size, o, f.path])


class Crypt:
    """Encrypted folder chooser"""
    def __init__(self, path=None, size=None):
        if path is not None and os.path.exists(path):
            widgets["crypt_path"].set_text(path)
            widgets["crypt_path"].set_sensitive(False)
            widgets["crypt_open"].set_sensitive(False)
        if size is not None and size.isdigit():
            widgets["crypt_size"].set_value(float(size))
            widgets["crypt_size"].set_sensitive(False)
        widgets["crypt"].show()


class Rencrypt(threading.Thread):
    """Encrypt while displaying a progressbar"""
    #def setFolder(self, folder):
    #    self.folder = folder
    
    def set_para(self, folder, password):
        """Set what folder and password to use"""
        self.folder = folder
        self.password = password

    def run(self):
        """Main"""
        try:
            cryptmanager.Manage(self.folder).crypt(self.password)
        except cryptmanager.IMGexists:
            progressbar.stop()
            widgets["crypt"].set_sensitive(True)
            Util().error_box(self.folder.path + " is already a crypted folder.")
        except cryptmanager.LoError:
            progressbar.stop()
            widgets["crypt"].set_sensitive(True)
            Util().error_box("No loopback device available.")
        else:
            folders.add(self.folder)
            progressbar.stop()
            widgets["crypt"].set_sensitive(True)
            widgets["crypt"].hide()
            if widgets["manager"].get_property("visible"):
                manager.update()
                widgets["manager"].set_sensitive(True)


class Encrypt:
    """Threads initiation for encrypting"""
    def __init__(self, path, size, password):
        global progressbar
        folder = cryptmanager.Folder(path, size)
        progressbar = Progressbar()
        r = Rencrypt()
        r.set_para(folder, password)
        widgets["crypt"].set_sensitive(False)
        progressbar.start()
        r.start()


class Open:
    """Open an encrypted folder"""
    def __init__(self, path):
        widgets["open_password"].set_text("")
        widgets["open_path"].set_text(path)
        widgets["open"].show()


class Decrypt:
    """Decrypt window"""
    def __init__(self, path):
        widgets["decrypt_password"].set_text("")
        widgets["decrypt_path"].set_text(path)
        widgets["decrypt"].show()

class Sdecrypt:
    """Decryption initiation"""
    def __init__(self, path, password):
        global progressbar
        progressbar = Progressbar()
        r = Rdecrypt()
        r.set_para(path, password)
        widgets["decrypt"].hide()
        progressbar.start()
        r.start()


class Rdecrypt(threading.Thread):
    """Real decryption"""  
    
    def set_para(self, path, password):
        """Set what path and password to use"""
        self.path = path
        self.password = password

    def run(self):
        """Main"""
        try:
            folder = folders.get(self.path)
        except cryptmanager.AlreadyOpened:
            progressbar.stop()
            if widgets["manager"].get_property("visible"):
                manager.set_sensitive(True)
            Util().error_box(folder.path + " is already opened.")
        try:
            cryptmanager.Manage(folder).decrypt(self.password)
        except cryptmanager.BadPassword:
            progressbar.stop()
            if widgets["manager"].get_property("visible"):
                widgets["manager"].set_sensitive(True)
            Util().error_box("Your password is wrong.")
        except cryptmanager.LoError:
            progressbar.stop()
            if widgets["manager"].get_property("visible"):
                widgets["manager"].set_sensitive(True)
            Util().error_box("No loopback device available.")
        else:
            folders.rem(folder)
            progressbar.stop()
            WidgetsWrapper.hide_or_quit(widgets, "decrypt")
            if widgets["manager"].get_property("visible"):
                widgets["manager"].set_sensitive(True)
                manager.update()


class Mount:
    """Mount an encrypted folder"""
    def __init__(self, path, password):
        try:
            folder = folders.get(path)
        except cryptmanager.NoEncrypted:
            Util().error_box("This is not a crypted directory.")
            return
        try:
            folder = cryptmanager.Manage(folder).mount(password)
        except cryptmanager.AlreadyOpened:
            Util().error_box(folder.path + " is already opened.")
        except cryptmanager.BadPassword:
            Util().error_box("Your password is wrong.")
        except cryptmanager.LoError:
            Util().error_box("No loopback device available.")
        else:
            folders.update(folder)
            WidgetsWrapper.hide_or_quit(widgets, "open")
            if widgets["manager"].get_property("visible"):
                manager.update()


class Unmount:
    def __init__(self, path):
        """Unmount an encrypted folder"""
        try:
            folder = folders.get(path)
        except cryptmanager.NoEncrypted:
            Util().error_box("This is not a crypted directory.")
        try:
            folder = cryptmanager.Manage(folder).unmount()
        except cryptmanager.NotOpened:
            Util().error_box("This folder is not opened.")
        folders.update(folder)
        if widgets["manager"].get_property("visible"):
            manager.update()


def save_data():
    if folders == None:
        return
    if not os.path.exists(CACHE):
        os.makedirs(CACHE)
    f = open(os.path.join(CACHE, "folders"), "w")
    cPickle.dump(folders, f, protocol = cPickle.HIGHEST_PROTOCOL)
    f.close()


def load_data():
    if not os.path.exists(os.path.join(CACHE, "folders")):
        return cryptmanager.Folders()
    f = open(os.path.join(CACHE, "folders"), "r")
    folders = cPickle.load(f)
    f.close()
    return folders


def exit(para=0):
    save_data()
    sys.exit(para)


if __name__ == '__main__':
    folders = load_data()
    folders.clean()
    gtk.gdk.threads_init()
    widgets = WidgetsWrapper()
    # Command Line Interface
    if len(sys.argv) == 1:
        manager = Manager(folders)
        
    elif len(sys.argv) == 2 and sys.argv[1] == "--info":
        msg = APPNAME + """, an encrypted folder manager
Options:
--crypt [DIRECTORY] [SIZE]  encrypt directory, size in MB
--open DIRECTORY            open an encrypted folder
--info                      display this help message
--close DIRECTORY           close an encrypted folder
--decrypt DIRECTORY         decrypt encrypted folder
--version                   display version information"""
        exit(msg)
        
    elif len(sys.argv) == 2 and sys.argv[1] == "--version":
        msg = APPNAME + " " + APPVERSION
        exit(msg)

    elif len(sys.argv) == 2 and sys.argv[1] == "--test":
        p = Progressbar("test")
        p.start()
    
    elif len(sys.argv) == 2 and sys.argv[1] == "--clean":
        folders.clean()
        exit()

    elif len(sys.argv) >= 2 and len(sys.argv) <= 4 and sys.argv[1] == "--crypt":
        if len(sys.argv) == 3:
            c = Crypt(sys.argv[2])
        elif len(sys.argv) == 4:
            c = Crypt(sys.argv[2], sys.argv[3])
        else:
            c = Crypt()

    elif len(sys.argv) == 3 and sys.argv[1] == "--close":
        Unmount(sys.argv[2])

    elif len(sys.argv) == 3 and sys.argv[1] == "--open":
        Open(sys.argv[2])

    elif len(sys.argv) == 3 and sys.argv[1] == "--decrypt":
        Decrypt(sys.argv[2])

    else:
        msg = """Invalid option
Try « """ + APPNAME + """ --info » to get more information"""
        Util().error_box(msg)
    
    gtk.main()
    exit()
