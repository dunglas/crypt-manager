#!/usr/bin/python
# vim: set fileencoding=utf-8 :
# Copyright (C) 2007 Kévin Dunglas <dunglas@gmail.com>
#
# Authors:
#  Kévin Dunglas
#
# This program is a part of a the Google Summer Of Code 2007
# For futher information see :
# http://code.google.com/soc/ubuntu/appinfo.html?csaid=EF4FCF874D88234
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA 02111-1307 USA

import os
import sys
import pygtk
pygtk.require('2.0')
import gtk
import gtk.glade
from time import sleep
import threading
import cryptmanager
import gnomekeyring

APPNAME="gcrypt-manager"
APPVERSION="0.1"
CACHE = os.environ['HOME'] + "/.cryptmanager/cache"
GLADE = "/usr/share/gcrypt-manager/gcrypt-manager.glade"

class Keyring:
    """Store passwords using GNOME Keyring if available"""
    
    # No documentation available for the Python binding of GNOME Keyring
    # Inspirated from the the following Gajim code
    # http://trac.gajim.org/browser/trunk/src/common/passwords.py
    
    def __init__(self, keyring):
        self.available = False
        self.keyring = keyring # Must be "default" or "session"
        
        # Test if the gnomekeyring module is installed
        try:
            import gnomekeyring
        except ImportError:
            self.available = False
            return

        # Test if GNOME Keyring is available
        if gnomekeyring.is_available():
            self.available = True
        else:
            return
        
        # Sync with the default keyring
        try:
            gnomekeyring.create_sync(self.keyring, None)
        except gnomekeyring.AlreadyExistsError:
            pass
    
    def save_password(self, folder, password):
        """Save a password for an encrypted folder identified by his digest"""
        
        if not self.available:
            return None
        
        attributes = {"path":folder.path, "crypt-manager":True}
        
        try:
        # Add an item
            return gnomekeyring.item_create_sync(
                self.keyring, # Keyring
                gnomekeyring.ITEM_GENERIC_SECRET, # Item type
                folder.digest, # Item name
                attributes, # Attributes
                password, # Password
                False) # Update if already exists
        except gnomekeyring.NoKeyringDaemonError:
            self.available = False
            return None
    
    def get_password(self, auth):
        """Get the password of an encrypted folder, return None if not stored"""
        
        if not self.available:
            return None
        
        try:
            return gnomekeyring.item_get_info_sync(self.keyring,
                auth).get_secret()
        except gnomekeyring.DeniedError:
            return None
        except gnomekeyring.NoKeyringDaemonError:
            self.available = False
            return None

 
class GladeHandlers:
    """Connectors to GTK/Glade events"""
    def gtk_main_quit(event):
        quit()

    def on_manager_add_clicked(event):
        windows["manager"]["manager"].set_sensitive(False)
        Crypt()

    def on_crypt_apply_clicked(event):
        path = windows["crypt"]["crypt_path"].get_text()
        password = windows["crypt"]["crypt_password"].get_text()
        confirmation = windows["crypt"]["crypt_confirmation"].get_text()
        if Util().valid_crypt(path, password, confirmation):
            Encrypt(path, password)
            #WidgetsWrapper.hide_or_quit(widgets, "crypt")

    def on_crypt_destroy(event):
        windows.hide_or_quit("crypt", 1)

    def on_crypt_cancel_clicked(event):
        windows.hide_or_quit("crypt", 1)
    
    def on_open_destroy(event):
        windows.hide_or_quit("open", 1)

    def on_open_cancel_clicked(event):
        windows.hide_or_quit("open", 1)
    
    def on_open_apply_clicked(event):
        if windows["open"]["open_autoclose"].get_active():
            idle = windows["open"]["open_time"].get_value_as_int()
        else:
            idle = None
        
        if windows["open"]["open_savepass"].get_active():
            i = windows["open"]["open_savechoice"].get_active()
            if i == 0:
                keyring = "session"
            else:
                keyring = "default"
        else:
            keyring = None
        
        Mount(windows["open"]["open_path"].get_text(),\
            windows["open"]["open_password"].get_text(), idle, keyring)
    
    def on_decrypt_destroy(event):
        windows.hide_or_quit("decrypt", 1)
    
    def on_decrypt_cancel_clicked(event):
        windows.hide_or_quit("decrypt", 1)
    
    def on_open_autoclose_toggled(event):
        if windows["open"]["open_autoclose"].get_active():
            windows["open"]["open_time"].set_sensitive(True)
        else:
             windows["open"]["open_time"].set_sensitive(False)
    
    def on_open_savepass_toggled(event):
        if windows["open"]["open_savepass"].get_active():
            windows["open"]["open_savechoice"].set_sensitive(True)
            windows["open"]["open_savechoice"].set_active(0)
        else:
            windows["open"]["open_savechoice"].set_sensitive(False)
    
    def on_decrypt_apply_clicked(event):
        Sdecrypt(windows["decrypt"]["decrypt_path"].get_text(),\
            windows["decrypt"]["decrypt_password"].get_text())
        windows.hide_or_quit("decrypt")
    
    def on_crypt_open_clicked(event):
        windows.load("filechooserdialog")
        
    def on_filechooserdialog_cancel_clicked(event):
        windows["filechooserdialog"]["filechooserdialog"].destroy()
    
    def on_filechooserdialog_open_clicked(event):
        path = windows["filechooserdialog"]["filechooserdialog"].get_filename()
        windows["crypt"]["crypt_path"].set_text(path)
        windows["filechooserdialog"]["filechooserdialog"].destroy()

    def on_error_close_clicked(event):
        windows["error"]["error"].destroy()
    
    def on_manager_list_cursor_changed(event):
        (m, i) = windows["manager"]["manager_list"].get_selection().\
            get_selected()
        if m.get_value(i, 1) == "Yes":
            windows["manager"]["manager_open_close"].set_label("gtk-close")
        else:
            windows["manager"]["manager_open_close"].set_label("gtk-open")
        windows["manager"]["manager_open_close"].set_sensitive(True)
        windows["manager"]["manager_decrypt"].set_sensitive(True)
        windows["manager"]["manager_properties"].set_sensitive(True)
    
    def on_manager_open_close_clicked(event):
        (m, i) = windows["manager"]["manager_list"].get_selection().\
            get_selected()
        path = m.get_value(i, 2)
        if m.get_value(i, 1) == "Yes":
            Unmount(path)
        else:
            windows["manager"]["manager"].set_sensitive(False)
            Open(path)
    
    def on_manager_properties_clicked(event):
        (m, i) = windows["manager"]["manager_list"].get_selection().get_selected()
        path = m.get_value(i, 2)
        windows.load("properties")
        windows["properties"]["properties_old"].set_text("")
        windows["properties"]["properties_new"].set_text("")
        windows["properties"]["properties_confirmation"].set_text("")
        windows["properties"]["properties_path"].set_text(path)
        windows["manager"]["manager"].set_sensitive(False)
        
    def on_manager_decrypt_clicked(event):
        windows["manager"]["manager"].set_sensitive(False)
        (m, i) = windows["manager"]["manager_list"].get_selection().\
            get_selected()
        path = m.get_value(i, 2)
        Decrypt(path)

    def on_properties_cancel_clicked(event):
        windows.hide_or_quit("properties")
    
    def on_properties_destroy(event):
        windows.hide_or_quit("properties")
    
    def on_properties_apply_clicked(event):
        old = windows["properties"]["properties_old"].get_text()
        new = windows["properties"]["properties_new"].get_text()
        confirmation = windows["properties"]["properties_confirmation"].\
            get_text()
        if Util().valid_properties(new, confirmation):
            ChangePassword(windows["properties"]["properties_path"].get_text(),\
                old, new)
    
    def on_properties_delete_event(event):
        return False


class Windows:
    """Wrapper for GTK/Glade windows"""
    def __init__(self):
        self.win = {}
    
    def load(self, name):
        self.win[name] = Widgets(name)
        
    def __getitem__(self, key):
        """Alow to use windows['window']['widget']"""
        return self.win[key]

    def hide_or_quit(self, name, para=0):
        """Hide the window if manager is still active, either quit"""
        try:
            manager.update()
            windows["manager"]["manager_open_close"].set_sensitive(False)
            windows["manager"]["manager_properties"].set_sensitive(False)
            windows["manager"]["manager_decrypt"].set_sensitive(False)
            windows["manager"]["manager"].set_sensitive(True)
            try:
                windows[name][name].destroy()
            except:
                pass
        except:
            quit(para)


class Widgets:
    """Wrapper for GTK/Glade widgets"""
    def __init__(self, window):
        """Display a window"""
        self.widgets = gtk.glade.XML("gcrypt-manager.glade", window)
        self.widgets.signal_autoconnect(GladeHandlers.__dict__)

    def __getitem__(self, key):
        """Allow to use windows['windows']['widget'].action()"""
        return self.widgets.get_widget(key)


class Util:
    """Utilities"""
    def error_box(self, msg):
        """Display an error box"""
        windows.load("error")
        windows["error"]["error_label"].set_markup("<span weight=\"bold\">" +\
            msg + "</span>")
    
    def warning_box(self, msg):
        """Display a warning box"""
        windows.load("warning")
        windows["warning"]["warning_label"].set_markup("<span weight=\"bold\">"\
            + msg + "</span>")

    def valid_crypt(self, path, password, confirmation):
        """Validation for the crypt window"""
        
        if not os.path.exists(path):
            self.error_box("You must select a valid folder")
            return False
        if len(password) == 0:
            self.error_box("Password can not be null")
            return False
        if not password == confirmation:
            self.error_box("Password do not match with the confirmation")
            return False
        return True
    
    def valid_properties(self, new, confirmation):
        """Validation for the crypt window"""
        if len(new) == 0:
            self.error_box("Password can not be null")
            return False
        if not new == confirmation:
            self.error_box("New password do not match with the confirmation")
            return False
        return True


class Pulser(threading.Thread):
    """Pulse the progressbar"""
    
    stopthread = threading.Event()
    
    def run(self):
        while not self.stopthread.isSet() :
            gtk.gdk.threads_enter()
            windows["progressbar"]["progressbar_progressbar"].pulse()
            gtk.gdk.threads_leave()
            sleep(0.1)

    def stop(self):
        """Stop method, sets the event to terminate the thread's main loop"""
        self.stopthread.set()


class Progressbar:
    """Display a pulsing progressbar"""
    def __init__(self, msg=None):
        self.msg = msg

    def start(self):
        """Start the progress bar"""
        windows.load("progressbar")
        if self.msg is not None:
            windows["progressbar"]["progressbar"].set_title(self.msg)
            windows["progressbar"]["progressbar_progressbar"].set_text(self.msg)
        self.pulser = Pulser()
        self.pulser.start()

    def stop(self):
        """Stop the progressbar"""
        self.pulser.stop()
        windows["progressbar"]["progressbar"].destroy()
    

class Manager:
    """Main window"""
    def __init__(self, folders):
        """Launch the Cypted Folder manager"""
        windows.load("manager")
        column0 = gtk.TreeViewColumn("Folder name", gtk.CellRendererText(),\
            text=0)
        column0.set_resizable(True)
        column0.set_sort_column_id(0)
                
        column1 = gtk.TreeViewColumn("Open", gtk.CellRendererText(), text=1)
        column1.set_resizable(True)
        column1.set_sort_column_id(2)
        
        column2 = gtk.TreeViewColumn("Full path", gtk.CellRendererText(),\
            text=2)
        column2.set_resizable(True)
        column2.set_sort_column_id(3)
        
        windows["manager"]["manager_list"].append_column(column0)
        windows["manager"]["manager_list"].append_column(column1)
        windows["manager"]["manager_list"].append_column(column2)
        
        self.folderList = gtk.ListStore(str, str, str)
        windows["manager"]["manager_list"].set_model(self.folderList)
        self.update()

    def update(self):
        """Update the tree view with the folders list"""
        self.folderList.clear()
        for f in folders.li:
            path = f.path.split("/")
            path = path[len(path) - 1]
            if f.opened == True:
                o = "Yes"
            else:
                o = "No"
            self.folderList.append([path, o, f.path])


class Crypt:
    """Encrypted folder chooser"""
    def __init__(self, path=None):
        windows.load("crypt")
        if path is not None and os.path.exists(path):
            windows["crypt"]["crypt_path"].set_text(path)
            windows["crypt"]["crypt_path"].set_sensitive(False)
            windows["crypt"]["crypt_open"].set_sensitive(False)


class Rencrypt(threading.Thread):
    """Encrypt while displaying a progressbar"""
    #def setFolder(self, folder):
    #    self.folder = folder
    
    def set_para(self, folder, password):
        """Set what folder and password to use"""
        self.folder = folder
        self.password = password

    def run(self):
        """Main"""
        try:
            cryptmanager.Manage(self.folder).crypt(self.password)
        except cryptmanager.AlreadyEncrypted:
            progressbar.stop()
            windows["crypt"]["crypt"].set_sensitive(True)
            Util().error_box(self.folder.path + " is already a crypted folder.")
        else:
            folders.add(self.folder)
            progressbar.stop()
            windows["crypt"]["crypt"].set_sensitive(True)
            windows.hide_or_quit("crypt")


class Encrypt:
    """Threads initiation for encrypting"""
    def __init__(self, path, password):
        global progressbar
        folder = cryptmanager.Folder(path)
        progressbar = Progressbar()
        r = Rencrypt()
        r.set_para(folder, password)
        windows["crypt"]["crypt"].set_sensitive(False)
        progressbar.start()
        r.start()


class Open:
    """Open an encrypted folder"""
    def __init__(self, path):
        try:
            folder = folders.get(path)
        except cryptmanager.NoEncrypted:
            Util().error_box("This is not an encrypted directory.")
            return
        
        # Try to get password in default keyring
        password = None
        k = Keyring("default")
        # Test if gnomekeyring is available
        if k.available:
            # Test if a "gnomekeyring_id" attribute is set
            try:
                # Get the gnomekeyring id
                auth = folder.attributes["gnomekeyring_id"]
            except:
                pass
            else:
                # Get the password
                password = k.get_password(auth)
                # If no password, try in the session keyring
                if password == None:
                    k = Keyring("session")
                    password = k.get_password(auth)
        
        if password == None:
            # If the password is always Null, prompt for the password
            windows.load("open")
            windows["open"]["open_path"].set_text(path)
        else:
            Mount(path, password)

class Decrypt:
    """Decrypt window"""
    def __init__(self, path):
        windows.load("decrypt")
        windows["decrypt"]["decrypt_password"].set_text("")
        windows["decrypt"]["decrypt_path"].set_text(path)


class Sdecrypt:
    """Decryption initiation"""
    def __init__(self, path, password):
        global progressbar
        progressbar = Progressbar()
        r = Rdecrypt()
        r.set_para(path, password)
        windows["decrypt"]["decrypt"].destroy()
        progressbar.start()
        r.start()


class Rdecrypt(threading.Thread):
    """Real decryption"""  
    
    def set_para(self, path, password):
        """Set what path and password to use"""
        self.path = path
        self.password = password

    def run(self):
        """Main"""
        try:
            folder = folders.get(self.path)
        except cryptmanager.AlreadyOpened:
            progressbar.stop()
            try:
                windows["manager"].set_sensitive(True)
            except:
                pass
            Util().error_box(folder.path + " is already opened.")
        try:
            cryptmanager.Manage(folder).decrypt(self.password)
        except cryptmanager.BadPassword:
            progressbar.stop()
            try:
                windows["manager"].set_sensitive(True)
            except:
                pass
            Util().error_box("Your password is wrong.")
        else:
            folders.rem(folder)
            progressbar.stop()
            windows.hide_or_quit("decrypt")


class Mount:
    """Mount an encrypted folder"""
    def __init__(self, path, password, idle=None, keyring=None):
        try:
            folder = folders.get(path)
        except cryptmanager.NoEncrypted:
            Util().error_box("This is not a crypted directory.")
            return
        try:
            folder = cryptmanager.Manage(folder).mount(password, idle)
        except cryptmanager.AlreadyOpened:
            Util().error_box(folder.path + " is already opened.")
        except cryptmanager.BadPassword:
            Util().error_box("Your password is wrong.")
        else:
            if not keyring == None:
                k = Keyring(keyring)
                folder.attributes["gnomekeyring_id"] =\
                    int(k.save_password(folder, password))
            folders.update(folder)
            windows.hide_or_quit("open")


class Unmount:
    """Unmount an encrypted folder"""
    def __init__(self, path):
        try:
            folder = folders.get(path)
        except cryptmanager.NoEncrypted:
            Util().error_box("This is not a crypted directory.")
        try:
            folder = cryptmanager.Manage(folder).unmount()
        except cryptmanager.NotOpened:
            Util().error_box("This folder is not opened.")
        else:
            folders.update(folder)
            try:
                manager.update()
            except:
                pass


class ChangePassword:
    """Change a folder password"""
    def __init__(self, path, old, new):
        try:
            folder = folders.get(path)
        except cryptmanager.NoEncrypted:
            Util().error_box("This is not a crypted directory.")
        try:
            folder = cryptmanager.Manage(folder).change_password(old, new)
        except cryptmanager.BadPassword:
            Util().error_box("Bad password.")
        else:
            windows.hide_or_quit("properties")

def quit(para=0):
    """Quit the program"""
    gtk.main_quit()
    exit(para)


def exit(para=0):
    data.save()
    sys.exit(para)


if __name__ == '__main__':
    data = cryptmanager.Data()
    folders = data.folders
    folders.clean()
    gtk.gdk.threads_init()
    windows = Windows()
    # Command Line Interface
    if len(sys.argv) == 1:
        manager = Manager(folders)
        
    elif len(sys.argv) == 2 and sys.argv[1] == "--info":
        msg = APPNAME + """, an encrypted folder manager
Options:
--crypt [DIRECTORY]         encrypt directory
--open DIRECTORY            open an encrypted folder
--info                      display this help message
--close DIRECTORY           close an encrypted folder
--decrypt DIRECTORY         decrypt encrypted folder
--version                   display version information"""
        exit(msg)
        
    elif len(sys.argv) == 2 and sys.argv[1] == "--version":
        msg = APPNAME + " " + APPVERSION
        exit(msg)
    
    elif len(sys.argv) == 2 and sys.argv[1] == "--clean":
        folders.clean()
        exit()

    elif len(sys.argv) >= 2 and len(sys.argv) <= 3 and sys.argv[1] == "--crypt":
        if len(sys.argv) == 3:
            c = Crypt(sys.argv[2])
        else:
            c = Crypt()

    elif len(sys.argv) == 3 and sys.argv[1] == "--close":
        Unmount(sys.argv[2])

    elif len(sys.argv) == 3 and sys.argv[1] == "--open":
        Open(sys.argv[2])

    elif len(sys.argv) == 3 and sys.argv[1] == "--decrypt":
        Decrypt(sys.argv[2])

    else:
        msg = """Invalid option
Try « """ + APPNAME + """ --info » to get more information"""
        Util().error_box(msg)
    
    gtk.main()
    exit()
